
% ***READ *** READ *** READ *** READ *** READ *** READ *** READ *** 

% This program is an example about how to find a solution that minimizes a cost function. 
% The cost function is defined in order to "solve" a set of (simultaneous) equations

% In this example I try to solve 4 equations generated by 4 range
% measurements (distance between a range sensor and 4 known landmarks, i.e.
% it is a triangulation case.)
% Note: you may add more landmarks, so the solver would give an averaged
% solution, which is good for dealing with errors in the measurements.

% The unknown variables are (x,y) (position of the sensor).
% I created a hypothetical map (positions of landmarks) and a
% hypothetical current position of the sensor. Then I simulated 4
% range measurements, from the position (x,y) and the 4 landmarks. Then I
% use the 4 measurements to infer the position (x,y). The inference
% process knows the MAP (positions of the landmarks) and the 4 polluted
% range measurements. It does not know the actual position (x,y), which needs to be
% estimated.
% Note that I add some "noise" to the simulated measurement in order to
% simulate the reality ==> existence of noise in measurements.

% by Jose Guivant. Originally introduced for MTRN2500, S2/2015
% Now, to be effectively used in: 
%   MTRN4110; for hexapod localization purposes.
%   MTRN4010; for evaluating performance of EKF.


function ExampleMinimizingCostFunctionA(slow)

if ~exist('slow','var'), slow=0 ; end;


% I will use this global variable to share some parameters, etc between
% multiple functions.(You may have implemented it in a ddiferent way.)
clc();
global ExtraInfo;


% Create some buffers for recording evolution of optimization
% For analysis purposes. It is not necessary for actual cases, in real-time processing.
InitRecordIterations() ;


% Some simulated map.
ExtraInfo.LandmarksCentersX = [ -10,1,+10,9 ] ;
ExtraInfo.LandmarksCentersY = [ 8,-8,8,-9 ] ;


% For animation/ teaching purposes.
% if "DoItSlowly" is > 0 , it will show the optmimization process in slow
% motion and graphically.
if slow,
ExtraInfo.DoItSlowly=0.05;  %<---------- if <> 0, it will pause, to show slow-motion movie.
else
ExtraInfo.DoItSlowly=0;
end
    
% Simulated position of robot  (A successful estimated solution must converge to
% these values)
RealRobotPosition = [1,2] ;



% simulate range measurements
noise = (rand(1,numel(ExtraInfo.LandmarksCentersX))-0.5)*2* 0.2 ;     
% We simulate some random noise, uniform distribution, range [-0.2,+0.2]. (up to 20cm amplitude!)

% We simulate the noisy measurements by corrupting the perfect measurements
% (by adding the synthetic noise)
ExtraInfo.RealValuesEquations= EvaluateSystemOfEquations( RealRobotPosition )+noise;


% I assume some initial guess, wrong but not "very wrong"
% The optimization tool needs an initial guess!
MyInitialGuessAboutParameters = [5.5,2.6];

% Usually, we try to propose a guess, that is close to the solution
% (so, we "help" the optimizer).
% (in htis case, it is possible, because we know the previous position of the platform)
%MyInitialGuessAboutParameters = 0.1+RealRobotPosition;

fprintf('Real Position (x,y)=[%.3f][%.3f]\n',RealRobotPosition(1:2));
fprintf('Initial guess (x,y)=[%.3f][%.3f]\n',MyInitialGuessAboutParameters(1:2));


% Some plots for showing the situation.
% NOT necessary in real applications!!!!
figure(3) ; clf ;
ExtraInfo.h = plot(MyInitialGuessAboutParameters(1),MyInitialGuessAboutParameters(2),'*');
hold on ; xlabel('x (m)') ; ylabel('y (m)') ;
plot(RealRobotPosition(1),RealRobotPosition(2),'sr');
plot(MyInitialGuessAboutParameters(1),MyInitialGuessAboutParameters(2),'+k');
plot(ExtraInfo.LandmarksCentersX,ExtraInfo.LandmarksCentersY,'ob')
axis([-12,12,-12,12]);
ExtraInfo.hTitle=title(''); zoom on; grid on;
legend({'currently estimated solution','Real position','Initial guess'});


% run the OPTIMIZATION function, provided by Matlab
% I use this function because is efficient and easy to be used. There are other 
% approaches for solving the problem. 
% The optimizer needs to call my cost function,
% "MyCostFunction", when it needs to evaluate the cost associated to
% different instances of the parameters we want to obtain.


options =  optimset('TolFun',1e-3,'TolX',1);  % for telling the optimizer, that we accept 
% a tolerance of 0.001 in the cost function.


tic() ; % just for analyzing performance (processing time)
EstimatedParameters = fminsearch(@MyCostFunction,MyInitialGuessAboutParameters,options);
tElapsed=toc();

% In this case, the cost function I define is "MyCostFunction". See the code
% below.

% ... DONE

fprintf('Solution achieved in t=[%.3f]ms\n',tElapsed*1000);
fprintf('Solution converged to (x,y)=[%.4f][%.4f]\n',EstimatedParameters(1),EstimatedParameters(2));


% update results.
set(ExtraInfo.h,'xdata',EstimatedParameters(1),'ydata',EstimatedParameters(2));
PlotRecordOfIterations(RealRobotPosition) ;


return
end


% -------------------------------------------------------------------
% Here is the COST function I want to minimize.
% It depends on the problem I try to solve.

% This function is called, many times, by the optimization function.
% so, it should be very fast (==> do it properly).
function cost = MyCostFunction(z)
 % "z" : specified by the optimizer.
 
global ExtraInfo; %.LandmarksCentersX;

% Evaluate equations for the proposed hypothesis ( currently, in z )
r = EvaluateSystemOfEquations(z);
err = ExtraInfo.RealValuesEquations - r ;
cost = sum(  abs(err) );  %I propose this cost function.
%Done!


% This part of the code is for producing an animation, in class.
% Just for teaching purposes. NOT NEEDED.
if (ExtraInfo.DoItSlowly>0)
    set(ExtraInfo.h,'xdata',z(1),'ydata',z(2));
    s=sprintf('(in SLOW Motion) X=[%.3f][%.3f]: cost=[%.3e]\n',z(1),z(2),cost);
    set(ExtraInfo.hTitle,'string',s);
    RecordIteration(z,cost);
    pause(ExtraInfo.DoItSlowly);
end;


return ;
end
% --------------------------------------------
% Function that evaluate the 3 equations of interest, for a given instance
% of X  (i.e. of (x,y) )
% You cna modify it to deal with a variable number of landamrks.
function r = EvaluateSystemOfEquations( X )
 global ExtraInfo; %.LandmarksCentersX;

 
 
%   *** I am trying to do this:  
%  i=1;
%  dx = ExtraInfo.LandmarksCentersX(i)-X(1) ; dy = ExtraInfo.LandmarksCentersY(i)-X(2) ;
%  r(i) = sqrt(  dx*dx+dy*dy ) ;
%  
%  i=2;
%  dx = ExtraInfo.LandmarksCentersX(i)-X(1) ; dy = ExtraInfo.LandmarksCentersY(i)-X(2) ;
%  r(i) = sqrt(  dx*dx+dy*dy ) ;
%  
%  i=3;
%  dx = ExtraInfo.LandmarksCentersX(i)-X(1) ; dy = ExtraInfo.LandmarksCentersY(i)-X(2) ;
%  r(i) = sqrt(  dx*dx+dy*dy ) ;
%  ...etc
 
% but I do it, using vectors oprations (faster, in Matlab).
 dxs = ExtraInfo.LandmarksCentersX-X(1);
 dys = ExtraInfo.LandmarksCentersY-X(2);
 r =  sqrt(dxs.*dxs+dys.*dys);
 
 
 
 return;
end
 
% --------------------------------------------------------------
%   JUST FOR PLOTTING / TEACHING / ANIMATION PURPOSES.
%   NOT NEEDED IN YOU IMPLEMENTATIONS. IT CONSUMES PROCESSING.

function RecordIteration(X,cost)
global ExtraInfo; %.LandmarksCentersX;
if (ExtraInfo.iBufferEvolution<ExtraInfo.LmaxBufferEvolution),
     ExtraInfo.BufferEvolution(:,ExtraInfo.iBufferEvolution)=[X(1);X(2);cost];
    ExtraInfo.iBufferEvolution=ExtraInfo.iBufferEvolution+1;
end;
return;
end
function InitRecordIterations()
    global ExtraInfo;
    ExtraInfo.LmaxBufferEvolution =5000;
    ExtraInfo.BufferEvolution = zeros(3,ExtraInfo.LmaxBufferEvolution,'single');
    ExtraInfo.iBufferEvolution =1;
return;
end
function PlotRecordOfIterations(RealRobotPosition)
global ExtraInfo;
ExtraInfo.iBufferEvolution=ExtraInfo.iBufferEvolution-1;
if ExtraInfo.iBufferEvolution>0,
   ExtraInfo.BufferEvolution=ExtraInfo.BufferEvolution(:,1:ExtraInfo.iBufferEvolution);
   figure(1) ; clf;  hold on; xlabel('x (m)') ; ylabel('y (m)') ; box on; zoom on ;
   plot( ExtraInfo.BufferEvolution(1,:),ExtraInfo.BufferEvolution(2,:),'c');
   plot( ExtraInfo.BufferEvolution(1,:),ExtraInfo.BufferEvolution(2,:),'.b');
   plot( ExtraInfo.BufferEvolution(1,[1,ExtraInfo.iBufferEvolution]),ExtraInfo.BufferEvolution(2,[1,ExtraInfo.iBufferEvolution]),'*r');
   plot(RealRobotPosition(1),RealRobotPosition(2),'sr');
   title('How the optimizer "navigated" the parameters space');
   
   figure(2) ; clf;  hold on;
   plot( ExtraInfo.BufferEvolution(3,:),'c');
   plot( ExtraInfo.BufferEvolution(3,:),'.');
   xlabel('Iteration');    ylabel('Cost'); box on; zoom on ;
   title('How the COST function evolved when was being minimized');
end;   
return;
end
% --------------------------------------------------------------



 % --------------------------------------------------------------

 % Things you may try:
 %  1) Not adding noise in the simulation (perfect mesurements)
 %  2) Increase noise ( "worse" sensors)                         (useful for  projects!)    
 %  3) Simulate using a variable number of landmarks (2,3,4 or 5). (useful for  projects!) 
 %  4) Simulate case of "laser" (range and bearing)              (useful for  projects!) 
 %  5) Simulate case of "camera" (just bearing) 
  
 % For questions: use Moodle Forum or email: j.guivant@unsw.edu.au

 
 % -------------------------------------------------------------------
 
